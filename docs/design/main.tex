\documentclass{article}
% \usepackage[utf8]{inputenc}
\usepackage[a4paper,margin=1in,lmargin=0.5in,rmargin=0.5in]{geometry}
\usepackage{listings}
% \usepackage{graphicx}
% \usepackage{amsthm,amsmath,amssymb,amsfonts}
% \usepackage{tikz}
% \usepackage{listings}
% \newcommand*\circled[1]{\tikz[baseline=(char.base)]{
%             \node[shape=circle,draw,inner sep=2pt] (char) {#1};}}
% 
% \newcommand{\divides}{\mid}
% \newcommand{\notdivides}{\nmid}
% 
% \usepackage{enumerate} 
% \usepackage{hyperref}
% \usepackage{tabularx}
% \linespread{1.2}
% 
% \usepackage{longtable}
% \usepackage{ltablex}

\usepackage{graphicx}
\usepackage{xltabular}
\usepackage{float}
\usepackage{hyperref}
\usepackage{ulem}

\usepackage[mode=buildnew,subpreambles=true]{standalone}
\usepackage{tikz}

\usepackage{fancyhdr} % package for headers and footers
\pagestyle{fancy}
% \counterwithin*{equation}{section}

\title{CSC207 Project Design Document}
\author{SAC \\ Shiqi Chen, Jianjun Zhao, Junxi Liu, Kaitian Zheng}

\date{December 2022}

\begin{document}

\maketitle

% \thispagestyle{fancy}

\section{Project Identification}

As stated in the phase 1 design document, this project intends to create an advance version of Tetris from Assignment 2, following the \href{https://tetris.wiki/Tetris_Guideline}{Tetris Design Guideline}. While the main goal does not differ significantly, our focus gradually shifted to creating a highly customizable and extensible Tetris. Users will be provided with various options to customize their own game.

\section{User Story}
This project uses the MVC pattern. The terms, ``model'', ``view'' and ``controller'' used below are related to the MVC pattern.

% \begin{xltabular}{\textwidth}{|X|X|X|l|l|l|}
\begin{xltabular}{\textwidth}{|p{2cm}|p{0.5cm}|p{1.5cm}|p{4cm}|p{4.7cm}|p{1.3cm}|p{1cm}|}
\hline
\textbf{Name}&\textbf{ID} &\textbf{Owner}&\textbf{Description}&\textbf{Implementation Details}&\textbf{Priority}&\textbf{Effort} \\

\hline Framework & 1.0 & Jianjun Zhao &
As a developer, I want to provide a modular and extensible API so that it would be easy to maintain the code and add new features without changing the core logic. &
Subdivide the Model into several subsystems including  \verb|GameMode|, \verb|RotationSystem|, \verb|Generator|, etc.  The Model only communicates with abstract interfaces such that all add-on features are easily replaceable. &
1 & 3 \\

\hline Score calculation & 1.1 & Shiqi Chen &
As a classic Tetris player, I want a scoring system which recognizes my advanced Tetris skills (like combos, back-to-back, T-spin, etc.) so that I can know how well I played. &
\textbf{Observer pattern}. \verb|ScoreSystemLayer| would maintain a list of \verb|ScoreObserver|'s which are notified whenever the Model ticks (advances a step). Then each score observer will calculate the score based on its own score scheme.&
1 & 3 \\

\hline \sout{Hold} & \sout{1.2} & & & Delayed to 3.2 because 2.5 Flexible View needs to be implemented first. & &  \\

\hline \sout{Piece Preview} & \sout{1.3} & & & Delayed to 3.4 because 2.5 Flexible View needs to be implemented first. & &  \\

\hline Colour scheme (Accessibility) & 1.4 & Junxi Liu &
As a user who has trouble distinguishing colours due to visual impairment such as colour blindness, I want a different colour scheme (like high-contrast) so that I can quickly distinguish GUI elements. &
\textbf{Strategy pattern}. Provide an interface \verb|ColorScheme| which represents a specific GUI colour scheme. Provide various concrete \verb|ColorScheme| (like \verb|HighContrastColor|, \verb|ClassicColor|, etc) to satisfy users with different needs. The View would render the GUI including every \verb|Piece| based on the \verb|ColorScheme| (strategy) it uses. &
2 & 2 \\

\hline Piece Generator & 1.5 & Kaitian Zheng &
As an advanced player and developer, I want to facilitate different kinds of piece generators. In this way, in some special game modes, we are able to make a perfect row clear according to the behind-scene algorithm. &
\textbf{Strategy Pattern} Maintain an extensible \verb|Generator| interface. The Model will delegate piece generating to a \verb|Generator| object. The model can change its \verb|Generator| (strategy) at any time. This facilitates the later modifications such as replacing with a new piece generator system. &
1 & 1 \\

\hline T-spin & 1.6 & Kaitian Zheng &
As an advanced player, I want to perform special operations like \href{https://tetris.wiki/T-Spin}{T-Spin} (i.e., a mechanism where tetris pieces rotate differently according to their position) so that I can have a more challenging game experience. &
\textbf{State pattern}. Assign Model a \verb|RotationState| object. A concrete State contains a specific rotation mechanism. The Model can be set to a different State so that its rotation behaviour changes accordingly. &
2 & 3 \\

\hline Game mode & 2.4 & Kaitian Zheng &
As a player, I want different kinds of game modes (e.g., marathon, 40-lines, time-limited) so that I can have various gaming experiences. &
\textbf{Mediator pattern} Provide two interfaces, \verb|GameCore| and \verb|GameLayer|. The \verb|GameCore| interface is a template for unique features in a Tetris game, such as piece generator and rotation system. The \verb|GameLayer| interface is a template for some stackable additional features, such as the score calculation system and timed mode. A mediator class \verb|GameMode| is provided to combine the \verb|GameCore| and a stack of \verb|GameLayer|. \verb|GameCore| and \verb|GameLayer| can be reused to compose new \verb|GameMode|. &
2 & 3 \\

\hline Flexible View & 2.5 & Junxi Liu &
As a user, I want to customize the position of GUI elements according to my own need such that I can have a satisfying layout &
\textbf{Template pattern} Provide an abstract class \verb|FloatController| that implements the logic of setting an element into a specific container (position). The client can add an arbitrary floating element by inheriting \verb|FloatController| and only override some intermediate steps (like setting a specific container) without reinventing the whole process. &
1 & 3 \\


\hline Hold & 3.2 & Junxi Liu &
As a classic Tetris player, I want the game to allow me to store the current \verb|Piece| for the later use so that I can decide which tetris piece to touch the floor first. &
Maintain a buffer in the model. The client can store the current \verb|Piece| in the buffer and/or switch the current \verb|Piece| with the one in the buffer at any time. &
2 & 1 \\

\hline Lock Delay & 3.3 & Jianjun Zhao &
As a user, I want the game not to lock the tetris piece once it touches the floor. Instead, I need a lock delay so that I can adjust where to place the tetris piece with more flexibility. &
When a tetris piece reaches bottom and is not a hard drop, start a \verb|Lock| timer that expires in a specific interval. When the next tick is reached, the user does not perform any movement, and the \verb|Lock| timer expired, then the current tetris piece will be fixed and a new piece is generated. &
2 & 1 \\

\hline Piece Preview  & 3.4 & Shiqi Chen &
As a classic Tetris player, I want a window showing the upcoming blocks so that I can plan where to place the tetris pieces in advance. &
Maintain a queue of variable length. The client can modify that length to change the number of tetris pieces they want to preview. A newly generated \verb|Piece| is enqueued. Dequeue a \verb|Piece| when it is rendered in the view. Render the queue in the view so that users can see the upcoming tetris pieces. &
3 & 3 \\

\hline Ghost \verb|Piece| & 3.5 & Jianjun Zhao &
As a beginner to Tetris, I want the user interface to show where a piece will be landed so that the number of mistakenly placed tetris pieces can be reduced. &
Calculate the position where a tetris piece will be placed in advance. Then temporarily land the tetris piece with a fainter colour at the expected position where it will land if allowed to drop. &
1 & 2 \\

\hline Timed Mode & 3.6 & Shiqi Chen &
As an advanced player, I want to set a timer when I play the game such that I can know how fast I can play. &
Add a new \verb|GameLayer| to calculate the time elapsed and check if a specified target of time has elapsed. The elapsed time will be displayed on the main view, and this layer will end the game once a target time is reached. &
3 & 1 \\

\hline Line Count Mode & 3.7 & Junxi Liu &
As a user, I want to benchmark the time required for me to clear a certain number of lines such that I can compete with other players.&
Add a \verb|GameLayer| to record the number of lines cleared and check if a specified target is reached. The number of lines cleared will be displayed on the main view, and this layer will end the game once the target number is reached. &
3 & 1 \\

\hline Tetris Effect & 3.9 & Jianjun Zhao &
As a player, I want Tetris pieces to have some special visual effects (like shadowing or blooming) such that the game would look fancy and more attractive. & Use \verb|javafx.GraphicsContext| to draw Tetris pieces. \verb|javafx.GraphicsContext| can take \verb|Effect| objects like \verb|Bloom| or \verb|DropShadow| as parameters.
&
3 & 1 \\
\hline
\end{xltabular}
% \end{table}

\newpage

\section{Software Design}

\subsection{Design Pattern 1: Observer}

\paragraph{Overview}
This pattern is used to implement user story 1.1 (Score Calculation).

\paragraph{UML Diagram}\hfill

\begin{figure}[H]
    \includestandalone[width=\linewidth]{score}
\end{figure}

\paragraph{Implementation Details}

\verb`ScoreSystemLayer` maintains a list of \verb`ScoreObservers` which observe the behaviour of the \verb`Model`. An \verb`ScoreObserver` can be added to or removed from the list at any time. Whenever the \verb`Model` updates, \verb`ScoreSystemLayer` will notify all its observers and passes them a \verb|DataPackage| (which contains all necessary information) by calling \verb`ScoreObserver.notifyAllObservers()` and. Once notified, a \verb`ScoreObserver` calculates the score based on its own business logic (e.g., a \verb`ComboScoreObserver` stores the current Combo and rewards players based on the combo they performed). The client can use the \verb`ScoreSystemLayer.getScore()` method to get the aggregate score rewarded. This implementation increases the flexibility of the score calculation scheme. Different kinds of score schemes can be added or removed as needed without modifying the core logic of the client.

\clearpage

\subsection{Design Pattern 2: Template Method}

\paragraph{Overview}
This pattern is used to implement user story 2.5 (Flexible View).

\paragraph{UML Diagram}\hfill

\begin{figure}[H]
    \includestandalone[width=\linewidth]{FloatController}
\end{figure}

\paragraph{Implementation Details}

A floating GUI element is an element that can adjust its position (container) as needed. The \verb`FloatController` is an abstract template class for controllers of those floating GUI elements. The abstract class contains a template method \verb|initialize()| that calls other methods in a specific order such that the \verb|root| element it stores will be properly initialized. \verb|initialize()| guarantees that a container is specified before the \verb|root| element is put inside. Other concrete \verb|FloatController|s only need to override some intermediate steps to change the behaviour. The code for initialization will be automatically reused.

\clearpage

\subsection{Design Pattern 3: Strategy}

\paragraph{Overview}
This pattern is used to implement user story 1.5 (Color scheme).

\paragraph{UML Diagram}\hfill

\begin{figure}[H]
    \includestandalone[width=\linewidth]{colorscheme}
\end{figure}

\paragraph{Implementation Details}

\verb`MainController` maintains a colouring strategy \verb`colorScheme`. \verb`MainController` delegates its color rendering task to \verb`colorScheme.render()` which assigns a colour to each GUI element. The client would be able to choose their own colour scheme by calling \verb|setColorScheme()|. An example of concrete \verb|ColorScheme| would be \verb`HighContrastColorScheme` designed for people with vision impairments, which makes GUI elements easily distinguishable.

\clearpage

\subsection{Design Pattern 4: State}

\paragraph{Overview}
This pattern is used to implement user story 2.3 (T-Spin).

\paragraph{UML Diagram}\hfill

\begin{figure}[H]
    \includestandalone[width=\linewidth]{spin}
\end{figure}

\paragraph{Implementation Details}

The essence of the T-spin implementation is a rotation system that rotates tetris pieces differently according to their different states. For example, \verb`SuperRotationState` represents the state where a basic rotation is obstructed by the wall and the game attempts to rotate the Pieces in an alternative way. \verb`Model` stores the reference to one of the concrete \verb`RotationState` and delegates the state-specific rotation function to it. The client can change the rotation method of a \verb|Model| by changing its state using \verb`setRotationState()`. \verb`RotationState` also stores a backreference to the \verb`Model` object such that \verb`RotationState` can change the \verb`currentState` of \verb`Model`.

\clearpage

\section{Expected Timeline}

\begin{description}
\item[Sprint 1] Transition from Assignment 2 starter code, complete refactoring for design patterns and basic functionality.
\item[Sprint 2] Release a version that functions similarly to a classic Tetris game, with various options for users to customize.
\item[Sprint 3] Merge all branches and resolve any conflict or bug. Finish code documentations, sanity tests, and the report.
\item[Major Milestones] The major milestones will be the implementations of several advanced operations such as T-spin and the optimizations of the feature of Tetris Game.
\end{description}

\begin{figure}[H]
    \includestandalone[width=\linewidth]{timeline}
\end{figure}

\end{document}
